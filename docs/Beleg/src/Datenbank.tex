\section{Datenbank}
\label{JumpDatenbank}
\subsection{Aufbau der Datenbank}
Der wir nur 3 Klassen besitzen, fiel auch der Aufbau der Datenbank entsprechend einfach aus. Zunächst wurde für jede Klasse eine neue Collection angelegt, was etwas einer Tabelle in einer relationalen Datenbank oder einem Ordner in einem Dateisystem entspricht. In diesen Collections können nun ein, oder mehrere XML-Files gespeichert werden. Wie wir in \autoref{JumpDBOneBIGManysmall} begründet haben, speichern wir hier nur jeweils eine Datei.
Zusätzlich wurde noch eine Collection angelegt für unsere Stored XQuerys. In dieser sind mehrere .xql-Dateien hinterlegt, für alle Abfragen, die durchgeführt werden müssen:
\begin{itemize}
	\item exist/rest/db/
	\begin{itemize}
		\item nutzer/nutzers.xml
		\item alben/alben.xml
		\item bilder/bilder.xml
		\item queries/
		\begin{itemize}
			\item allNutzer.xql
			\item albenForNutzer.xql
			\item[] ...
			\item bilderForAlbum.xql
		\end{itemize}
	\end{itemize}
\end{itemize}
Für den Aufbau der einzelnen XML-Dateien sind im Anhang Beispiele unter \autoref{JumpListingNutzerXML}, \autoref{JumpListingAlbumXML} und \autoref{JumpListingBildXML} zu finden.
\todo{XML-Dateien in Anhang verschieben}
\begin{lstlisting}[caption=Beispiel für einen Eintrag in der nutzers.xml,label=JumpListingNutzerXML,language=XML]
<nutzer>
    <id>0</id>
    <name>Karl</name>
    <password>98f6bcd4621d373cade4e832627b4f6</password>
    <email>karl@web.de</email>
</nutzer>
\end{lstlisting}
\begin{lstlisting}[caption=Beispiel für einen Eintrag in der alben.xml,label=JumpListingAlbumXML,language=XML]
<album>
    <id>0</id>
    <name>Görlitz</name>
    <password>9e229f114819f62674b5b1a031a9f91</password>
    <description>Bilder über die Stadt Görlitz.</description>
    <nutzer>0</nutzer>
</album>\end{lstlisting}
\begin{lstlisting}[caption=Beispiel für einen Eintrag in der bilder.xml,label=JumpListingBildXML,language=XML]
<bild>
    <id>2</id>
    <name>Vogtshof Innenhof</name>
    <description>Studenten beim Grillen</description>
    <ispublic>false</ispublic>
    <date>2011-02-21 19:05:01</date>
    <fileposition>/pics/Vogtshof_Innenhof_3.jpg</fileposition>
    <album>0</album>
    <position>
        <latitude>51.148833</latitude>
        <longitude>51.148833</longitude>
        <altitude>123</altitude>
        <direction>120</direction>
    </position>
</bild>
\end{lstlisting}
\subsection{Mockklassen}
Da die Datenbank noch nicht zu Beginn der Implementierungsphase komplett einsatzfähig war, musste eine Zwischenlösung her, damit bereits einfache Funktionalitäten getestet werden konnten. Die Idee war es Mockklassen zu verwenden. Dazu wurden zunächst Interfaces für alle sogenannten Konnektor-Klassen angelegt. Die Mockklassen zu den einzelnen Interfaces implementieren bereits einen großen Teil dieser Funktionen, ohne dabei im Hintergrund mit der Datenbank zu kommunizieren. Demnach bieten die Mockklassen auch nur eine eingeschränkte Funktionalität, wie die Rückgabe eines Benutzers zu einer ID oder die Suche nach bestimmten Alben, basierend auf einer Menge von Testdaten. Eintragen, Löschen oder Modifizieren dieser Daten ist mit den Mockklassen dabei nicht möglich.\\
Wird nun eine solche Klasse erzeugt, werden die Testdaten automatisch generiert und können genutzt werden. Später kann die jeweilige Mockklasse einfach mit der 'echten' Implementierung ausgetauscht werden. 
Ein Beispiel einer solchen Mockklasse, in dem Fall der MockAlbumConnector ist im Anhang unter \autoref{JumpListingMockAlbumConnector} angegeben. Der Einfachheit halber werden ähnliche oder nicht implementierte Methoden weggelassen.

\begin{lstlisting}[caption=Die Klasse MockAlbumConnector,label=JumpListingMockAlbumConnector]
public class MockAlbumConnector implements IAlbumConnector {
  //Mehrere HashMaps um den Implementierungsaufwand in Grenzen zu Halten
  private final HashMap<Integer, Document> albenIDMap;
  private final HashMap<String, Document> albenNameMap;
  private final HashMap<Integer, Document> albenNutzerIDMap;
  private final HashMap<String, Document> albenDescriptionMap;
  int id = -1;

  public MockAlbumConnector(){
    this.albenIDMap = new HashMap<Integer,Document>();
    this.albenNameMap = new HashMap<String,Document>();
    this.albenNutzerIDMap = new HashMap<Integer,Document>();
    this.albenDescriptionMap = new HashMap<String,Document>();
    //Passwortverschlüsselung für ein Album
    String password = "goerlitz";
    try {
      MessageDigest md = MessageDigest.getInstance("md5");
      byte[] digest = md.digest(password.getBytes());
      StringBuffer hexString = new StringBuffer();
      for (int i = 0; i < digest.length; i++) {
        hexString.append(Integer.toHexString(0xFF & digest[i]));
      }
      password = hexString.toString();
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
    this.addAlbum("Görlitz", password, "Bilder über die Stadt Görlitz.", 0);
    ...
  }
  //Methode um ein Album den Testdaten hinzuzufügen
  private void addAlbum(String name, String password, String description, int nutzerID){
    this.id++;
    try {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      Document doc = factory.newDocumentBuilder().newDocument();
      Element idElem = doc.createElement("id");
      Element nameElem = doc.createElement("name");
      Element passwordElem = doc.createElement("password");
      Element descriptionElem = doc.createElement("description");
      Element nutzerElem = doc.createElement("nutzer");
      idElem.setTextContent(""+this.id);
      nameElem.setTextContent(name);
      passwordElem.setTextContent(password);
      descriptionElem.setTextContent(description);
      nutzerElem.setTextContent("" + nutzerID);
      Node albumNode = doc.createElement("album");
      albumNode.appendChild(idElem);
      albumNode.appendChild(nameElem);
      albumNode.appendChild(passwordElem);
      albumNode.appendChild(descriptionElem);
      albumNode.appendChild(nutzerElem);
      doc.appendChild(albumNode);
      this.albenIDMap.put(this.id, doc);
      this.albenNameMap.put(name, doc);
      this.albenNutzerIDMap.put(nutzerID + this.id, doc);
      this.albenDescriptionMap.put(description, doc);
    } catch (ParserConfigurationException e) {
      System.out.println("Fehler beim Erstellen des Albums " + name + ".");
      e.printStackTrace();
    }
  }
  ...
  public Document getAlbumByID(int id) throws ConnectException, IllegalArgumentException {
    if(this.albenIDMap.containsKey(id))
      return this.albenIDMap.get(id);
    else
      throw new IllegalArgumentException("");
  }
  ...
  public Document getAllAlben() throws ConnectException {
    try {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      Document doc = factory.newDocumentBuilder().newDocument();
      Node albenNode = doc.createElement("alben");
      for(Map.Entry<Integer,Document> entry : this.albenIDMap.entrySet()){
        albenNode.appendChild(doc.adoptNode(entry.getValue().getFirstChild()));
      }
      doc.appendChild(albenNode);
      return doc;
    } catch (ParserConfigurationException e) {
      System.out.println("Fehler beim Erstellen des Dokuments für alle Alben.");
      e.printStackTrace();
    }
    return null;
  }

  //Ähnlich wie alle Alben, nur mit Prüfung, ob das Album dem angegebenen Nutzer gehört
  public Document getAlbenForNutzer(int nutzerID) throws ConnectException, IllegalArgumentException {
    try {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      Document doc = factory.newDocumentBuilder().newDocument();
      Node albenNode = doc.createElement("alben");
      for(Map.Entry<Integer,Document> entry : this.albenIDMap.entrySet()){
        if(entry.getValue().getElementsByTagName("nutzer").item(0).getTextContent().equals(""+nutzerID))
          albenNode.appendChild(doc.adoptNode(entry.getValue().getFirstChild()));
      }
      doc.appendChild(albenNode);
      return doc;
    } catch (ParserConfigurationException e) {
      System.out.println("Fehler beim Erstellen des Dokuments für alle Alben.");
      e.printStackTrace();
    }
    return null;
  }
  ...
}
\end{lstlisting}
\subsection{Datensicherheit}

\subsection{Stored XQueries}

\subsection{Zugriff auf die Datenbank}

\subsection{Verhinderung gleichzeitiger Zugriffe}