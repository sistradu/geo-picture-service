\section{Applikation}
\label{JumpApplikation}
%TODO anderen Namen vergeben?, Unterabschnitte anpassen
\subsection{Controller}
\subsubsection{UserController}
Die gesamte Benutzerverwaltung regelt der Usercontroller. Er stellt u.a. Methoden für die Kontoerstellung, die Anmeldung und das Zusenden eines neuen Passworts zur Verfügung. Außerdem wird in einer Variable die Information bereitgestellt, ob ein Benutzer angemeldet ist oder nicht. Dies ist für die Darstellung der Webseiten von großer Bedeutung. Da nicht alles für unangemeldete Benutzer angezeigt werden soll, werden "`private"' Bereiche mittels "`rendered"'-Attribut nur angezeigt, wenn der Benutzer angemeldet ist.\\
\\
Das Anlegen eines neuen Benutzkontos läuft wie folgt ab. Der Benutzer wählt einen Benutzernamen und gibt seine EMail-Adresse an. An diese Adresse wird ein zufälllig generiertes Passwort gesendet. Auf diese Weise soll verifiziert werden, ob es die EMail-Adresse wirklich gibt. Sollte ein Benutzer nämlich sein Passwort vergessen, wird ein neues Passwort an diese EMail-Adresse gesendet. Für das zufällige Erzeugen des Passworts wird mittels einer Zufallszahl ein Buchstabe oder eine Zahl aus einer vorgegebenen Auswahl von Zeichen gewhählt und in einem String verkettet. Den Code der Methode findet man im Anhang auf Seite \pageref{lstRandomPasswort} im Listing \autoref{lstRandomPasswort}.\\
\\
Beim Umgang mit Benutzerdaten gibt es immer auch Anforderungen an die Sicherheit. So soll es vermieden werden, dass Passwörter unverschlüsselt gespeichert werden. Unter Beachtung dieses Hinweises werden die Passwörter deswegen verschlüssselt gespeichert. Als Verschlüsselungsmethode wird der Hash-Algorithmus MD5 verwendet. Sobald ein Passwort von der View an den Controller übergeben wird, erfolgt die Verschlüsselung bereits im Setter für die Passwortvariable. Auf diese Weise wird verhindert, dass irgendwo in der Anwendung ein unverschlüsseltes Passwort zur Verfügung steht. Um nun festzustellen ob das vom Benutzer eingegebene Passwort das Richtige ist, wird das bei der Eingabe verschlüsselte Passwort mit dem Passwort aus der Datenbank verglichen. Sobald diese beiden Passwörter übereinstimmen erfolgt die Anmeldung. Die Methode, die das Verschlüsseln bewerkstelligt findet man wieder im Anhang im Listing \autoref{lstEncryptPasswort} auf Seite \pageref{lstEncryptPasswort}.\\
\\
Wie bereits weiter oben erwähnt, werden EMails zur Verifizierung bzw. Zum Zurücksetzen des Passworts verschickt. Dafür wird die JavaMailAPI von Oracle verwendet. Aus dieser API werden allerdings nur die "`mailapi.jar"' und die "`smtp.jar"' verwendet, da die anderen jar-Dateien wie z.B "`imap.jar"' nicht benötigt werden. Die JavaMailAPI bietet Methoden an, damit der Inhalt der EMail und Verbindungseigenschaften zum Server gesetzt werden können. So kann z.B. eingestellt werden, dass die Verbindung zum Server über SSL hergestellt werden soll. Im Listing \autoref{lstMailversand} auf Seite \pageref{lstMailversand} im Anhang findet man die Methode, mit der die EMails versendet werden.

\subsubsection{CreateEditAlbumController}
\label{subsubsec:CreateEditAlbumController}
Hinter diesem eigentümlichen Namen befindet sich der Controller zum Erstellen und Bearbeiten von Alben. Es liegt auf der Hand, dass sich eine Webseite zum Erstellen und zum Bearbeiten eines Albums nicht sehr unterscheiden. Daher bietet es sich an für beide Aufgaben eine Webseite mit einem Controller zu erstellen. Die wenigen Dinge die sich auf der Webseite unterscheiden werden wieder mit einem "`rendered"'-Attribut versehen. Im Controller gibt es eine Boolean-Variable "`isNewAlbum"' mit der festgestellt werden kann ob ein neues Album erstellt oder bearbeitet wird.\\
\\
Bei der Erstellung eines neuen Albums werden natürlich auch Bilder hinzugefügt. Das Hochladen der Bilder erfolgt über eine Primafaces-Komponente die auf Seite \pageref{subsec:FileUpload} im Abschnitt \autoref{subsec:FileUpload} beschrieben wird. Diese Komponente braucht eine Methode, die das von der Komponente ausgelöste FileUploadEvent entgegen nimmt und verarbeitet. Den Code der Methode findet man im Anhang auf Seite \pageref{lstHandleFileUpload} im Listing \autoref{lstHandleFileUpload}.\\
\\
Wir haben uns dazu entschieden das Bild im Dateisystem abzuspeichern und in der Datenbank lediglich den Pfad abzuspeichern. Der Grund dafür ist, dass sonst bei der Speicherung in der Datenbank die Bilder erst aufwendig encodiert werden müssten. Sobald dann später die Bilder aus der Datenbank geholt werden, müsste man außerdem wieder die Daten zu einem JPEG-Bild konvertieren. Diesen Mehraufwand konnten wir durch die Speicherung im Dateisystem umgehen. Außerdem gibt es mit unserem Verfahren weniger Probleme wenn mehrere Bilder auf einmal hochgeladen werden. Das Upload-Verzeichnis an sich liegt irgendwo im Dateisystem. Die einfachste Möglichkeit wäre zwar der web-Ordner der Applikation gewesen, aber dort wäre die Bilder bei jedem Neudeploy gelöscht worden. Aus diesem Grund gibt es ein extra Verzeichnis wo alle Bilder abgespeichert werden.\\
\\
%TODO getImage beschreiben.
\subsection{AlbumController}
Der AlbumController gehört zu der Seite showAlbum.xhtml und kümmert sich darum die Pfade und Bildinformationen aus der Datenbank zum ausgewählten Album und von der Festplatte zu laden. Mit Hilfe der Methode getAlbumByName(String name) des IAlbumConnector bekommt man ein XML-Dokument geliefert, welches alle Informationen zu dem über den Parameter übergebenen Albumname enthält. Unteranderem ist auch die AlbumID dabei, diese wird für die Abfrage der Bilder des Albums benötigt. Hierfür wird die Methode getBilderForAlbum(int albumID) von IBildconnector verwendet. Wiederum erhält man ein XML-Dokument, dass iterativ nach den Bildern durchsucht werden kann. Anschließend werden sie einem Listen-Objekt vom Typ Bild hinzugefügt. Durch eine Getter-Methode die in einem Galleria-Tag aufgerufen wird, werden diese der Galerie hinzugefügt und angezeigt. Diese Variante funktioniert aber nur, wenn die Bilder statisch im Web-Ordner liegen. Um dynamische Bilder anzeigen zu können, wie hier benötigt, muss ein Umweg gegangen werden. So muss sichergestellt werden, dass es ein Objekt vom Typ StreamedContent gibt und per Getter erreichbar ist. Dieses muss bei jedem Wechsel des Bildes neu geladen werden. Dazu wird in der XHTML-Seite folgender Quellcode benötigt:
\begin{lstlisting}[caption=showAlbum.xml Galleria]
<h:outputLabel value="#{albumController.getImage(pics.name)}"/>
<p:graphicImage value="#{albumController.picture}"
title="#{pics.name}" alt="#{pics.beschreibung}">
</p:graphicImage>
\end{lstlisting}
Wenn das Outputlabel gerendert wird, dann erfolgt die Ausführung der Methode albumController.getImage(pics.name). Dies ist erst seit Tomcat 7 möglich. Im Controller wird das Bild mit dem übergebenen Bildnamen geladen und in der Variable picture abgelegt. Diese wird von der Primefaces-Komponente graphicImage geladen und angezeigt. Allerdings funktioniert diese Variante unter Primefaces 2 nicht korrekt. So wird auf Grund eines Caching bereits beim Aufrufen der Seite alle Bilder durchiteriert und somit wird nur das letzte Bild angezeigt. Das Fehlverhalten soll mit der neuen Version 3 von Primefaces behoben werden. Dies konnte in dem bisher verfügbaren Milestone jedoch nicht bestätigt werden. Dafür soll mit der neuen Fassung die Komponente ImageSwitch die Funktionalität erhalten, ob dies der Fall ist, wurde nicht untersucht.
\subsection{MapBean}
Für die Nutzung der Google-Maps-Komponente wird eine Bean benötigt. Diese hat die Aufgabe die Marker für die Karte zu erstellen, die Linie dazwischen einzuzeichnen und auf Anfrage das Bild zu einem Marker zu laden. Die ersten zwei müssen beim Erstellen der HTML-Seite durchgeführt werden, dazu wird die Funktion makeMarker() benötigt, welche im Listing \ref{lstMakeMarker} auf Seite \pageref{lstMakeMarker} gezeigt wird. Die Methode überschreibt die MapModel-Variable, welche vom gmap-Tag benutzt wird (siehe dazu: Kapitel \ref{GMap} auf Seite \pageref{GMap}). Dem Model werden die Overlays hinzugefügt, die dann auf der Karte angezeigt werden. Für einen Marker wird ein Objekt vom Typ Marker aus dem Paket org.primefaces.model.map benötigt. Der Konstruktor fordert ein Objekt vom Typ LatLng, einen String der den Titel repräsentiert und ein Object, dass beim triggern des Events ausgewertet werden kann. In diesem Fall wird es dazu verwendet, um den Pfad des Bildes zu übergeben, damit es von der Festplatte gelesen und als Streamed Content zurückgegeben und angezeigt werden kann. Das Objekt LatLng verlangt im Konstruktor zwei Werte vom Typ double, sie repräsentieren Latitude und Longitude, also die geografische Breite und Länge. Um zwei Marker miteinander verbinden zu können und somit eine Route darzustellen, bekommt das Objekt Polyline die Koordinaten der Marker übergeben. Nachdem alle enthalten sind, wird es dem MapModel hinzugefügt. Das Aussehen der Linie lässt sich mit Hilfe diverser Methode individuell anpassen, so wurde in diesem Fall die Breite, Farbe und Durchsichtigkeit angepasst. Die verwendeten Methodenaufrufe sind im Listing zur MapBean enthalten.
\subsection{Scopes}
\subsection{Beanzugriff}
\subsection{MessageProperties}
Bei der Entwicklung einer Webapplikation ist ein wichtiges Thema was man vorher planen sollte die Internationalisierung. Weiß man von Anfang an, dass es die Applikation nur in einer Sprache geben soll, kann man die Nachrichten bzw. Texte fest hinein schreiben. Weiß man das aber zu Beginn noch nicht genau, oder möchte die Applikation in mehreren Sprachen veröffentlichen, so sollte man die JSF-Komponente message bundle verwenden. Das sorgt dafür, dass die Zeichenketten der Nachrichten unabhängig von der Applikation gespeichert werden und schnell einfacher ausgetauscht werden können, oder schon in mehreren Sprachen dort vorliegen. Um zu entscheiden welche der Sprachversionen genutzt werden soll kann man sich des Lokalisierungscodes eine JSF-Anwendung bei der Ausführung bedienen. Dieser Lokalisierungscode besteht aus zwei Teilen, dem Code der Sprache und die Festlegung eines Stattes in der die Applikation laufen soll. Welche Codes die Applikation unterstützt kann in der faces-config.xml festgelegt werden.
\begin{lstlisting}[caption=faces-config.xml Lokalisierungscode]{Name}
<locale-config>
            <default-locale>de</default-locale>
            <!--<supported-locale>de</supported-locale>-->
</locale-config>
\end{lstlisting}
Dort kann ein Standardwert festgelegt werden mit dem Tag "'<default-locale>"' und die weiteren Lokalisierungen, die unterstützt werden. In dieser Applikation wird lediglich die Lokalisierung für Deutschland unterstützt.
Des weiteren muss man festlegen, wo die Applikation die Nachrichten bzw. Texte finden kann. Das passiert ebenfalls in der faces-config.xml durch das "'<message-bundle>"' Tag.
\begin{lstlisting}[caption=faces-config.xml message bundle]
<message-bundle>bundle.message</message-bundle>
\end{lstlisting}
In diesem Fall das Package bundle und dort die Datei "'message.properties"'. \\
\\
Die Texte der Applikation werden dann wie folgt in die "'message.properties"' eingetragen:
\begin{lstlisting}[caption=message.properties]
home = Startseite
ungueltigerBenutzerName = Der Benutzername ist ungültig!
welcometext = Herzlich Willkommen auf GPicS!
\end{lstlisting}
Das sind natürlich nicht alle Nachrichten, sondern nur eine sehr kleine Auswahl um das Prinzip zu verdeutlichen.\\
\\
Um nun in einem XHTML-File auf die Nachrichten zuzugreifen, wurde in der faces-config.xml der Pfad sowie eine Variable festgelegt:
\begin{lstlisting}[caption=message.properties XHMTL-Variable]
<resource-bundle>
    <base-name>/bundle/message</base-name>
    <var>msg</var>
</resource-bundle>
\end{lstlisting}
Der Text wird dann wie folge aufgerufen:
\begin{lstlisting}[caption=message.properties Aufruf mit XHMTL-Variable]
<h:outputLabel value="#{msg.bildname} "/>
\end{lstlisting}
Mit diesem Aufruf wird folgende Zeile der "'message.properties"' aufgerufen:
\begin{lstlisting}[caption=message.properties XHMTL-Variable Teil 2]
bildname = Name
\end{lstlisting}
Somit wird das Label den Namen "'Name"' bekommen.\\
\\
Will man in einem Controller auf die "'message-properties"' zugreifen, geht das wie folgt.
Die jeweiligen Nachrichten werden dann durch folgende Methode an der jeweiligen Stelle der Applikation aus der "'message.properties"' geladen:
\begin{lstlisting}[caption=message.properties Aufruf aus Controller]
MessagePropertiesBean msgPB = new MessagePropertiesBean();
String pfad = msgPB.getPropertiesMessage("defaultPicturePath");
\end{lstlisting}

Dafür wird die die Methode "'getPropertiesMessage()"'  der Klasse MessagesPropertiesBean aus dem Package util genutzt.

\begin{lstlisting}[caption=message.properties Aufruf aus Controller Teil 2]
public String getPropertiesMessage(String key) {

		FacesContext context = FacesContext.getCurrentInstance();

		String text = GPicSUtil.getMessageResourceString(context.getApplication()
                .getMessageBundle(), key, null, context.getViewRoot()
                .getLocale());

return text;
	}
\end{lstlisting}

Der Methode wird ein String übergeben, der wiederum einer weiteren Methode der Klasse GPicSUtil übergeben wird.

\begin{lstlisting}[caption=message.properties Aufruf aus Controller Teil 3]
public static String getMessageResourceString(
    String bundleName,
    String key,
    Object params[],
    Locale locale){

        String text = null;

        ResourceBundle bundle =
                ResourceBundle.getBundle(bundleName, locale,
                                        getCurrentClassLoader(params));

        try{
            text = bundle.getString(key);
        } catch(MissingResourceException e){
            text = "?? key " + key + " not found ??";
        }

        if(params != null){
            MessageFormat mf = new MessageFormat(text, locale);
            text = mf.format(params, new StringBuffer(), null).toString();
        }

    return text;
}
\end{lstlisting}
Diese Methode durchsucht dann das "'message-properties"'-File und gibt den Text zurück, soweit er gefunden wird.
\subsection{EMail}
Für die Benutzerkontoerstellung und das Zusenden eines neuen Passworts haben wir in unserem Projekt die Möglichkeit vorgesehen EMails zu versenden. Da der EMail-Versand zwingend ein EMail-Account erfordert, haben wir einen Mailserver eingerichtet, womit diese EMails verschickt werden konnten. Allerdings haben wir relative schnell Probleme festgestellt. So funktionierte das Schicken der Mails nur an die Hochschul-EMail-Adresse. Bei anderen Mail-Anbietern kamen keine EMails an. Sie wurden noch nicht einmal im Spam Ordner angezeigt. Der Grund hierfür liegt wahrscheinlich darin, dass die anderen Mail-Anbieter unsere Adresse nicht als vertrauenswürdig einstuften.\\
\\
Dies war aber nicht das einzigste Problem. Probleme mit unserem VServer erzwangen ein Neustart des Mail-Servers. Danach hat das Senden von Mails nicht mehr funktioniert. Wo die Gründe liegen ist leider nicht ohne eine aufwendige Problemanalyse raus zu bekommen. In Anbetracht der knappen Zeit haben wir uns dafür entschieden, bei GMX ein Mailkonto einzurichten und über diese Adresse die Mails zu schicken.\\
\\
Nun steht natürlich die Frage im Raum warum wir das nicht von Anfang an gemacht haben und uns mit dem Aufwand, dem Einrichten eines Mailservers, viel Arbeit aufgeladen haben. Der Grund dafür waren bedenken, einen "`Sinnlos-Account"' einzurichten. Es werden ja nur einige wenige EMails versendet. Außerdem macht eine eigene EMail-Adresse immer einen besseren Eindruck. Wäre mehr Zeit gewesen hätten wir sicher das Problem mit unserem Mailserver lösen können, aber so mussten wir eben diese Alternative verwenden.