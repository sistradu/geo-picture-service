\section{Applikation}
\label{JumpApplikation}
%TODO anderen Namen vergeben?, Unterabschnitte anpassen
\subsection{Controller}
\subsubsection{UserController}
Die gesamte Benutzerverwaltung regelt der Usercontroller. Er stellt u.a. Methoden für die Kontoerstellung, die Anmeldung und das Zusenden eines neuen Passworts zur Verfügung. Außerdem wird in einer Variable die Information bereitgestellt, ob ein Benutzer angemeldet ist oder nicht. Dies ist für die Darstellung der Webseiten von großer Bedeutung. Da nicht alles für unangemeldete Benutzer angezeigt werden soll, werden "`private"' Bereiche mittels "`rendered"'-Attribut nur angezeigt, wenn der Benutzer angemeldet ist.\\
\\
Das Anlegen eines neuen Benutzkontos läuft wie folgt ab. Der Benutzer wählt einen Benutzernamen und gibt seine EMail-Adresse an. An diese Adresse wird ein zufälllig generiertes Passwort gesendet. Auf diese Weise soll verifiziert werden, ob es die EMail-Adresse wirklich gibt. Sollte ein Benutzer nämlich sein Passwort vergessen, wird ein neues Passwort an diese EMail-Adresse gesendet. Für das zufällige Erzeugen des Passworts wird mittels einer Zufallszahl ein Buchstabe oder eine Zahl aus einer vorgegebenen Auswahl von Zeichen gewhählt und in einem String verkettet. Den Code der Methode findet man im Anhang auf Seite \pageref{lstRandomPasswort} im Listing \autoref{lstRandomPasswort}.\\
\\
Beim Umgang mit Benutzerdaten gibt es immer auch Anforderungen an die Sicherheit. So soll es vermieden werden, dass Passwörter unverschlüsselt gespeichert werden. Unter Beachtung dieses Hinweises werden die Passwörter deswegen verschlüssselt gespeichert. Als Verschlüsselungsmethode wird der Hash-Algorithmus MD5 verwendet. Sobald ein Passwort von der View an den Controller übergeben wird, erfolgt die Verschlüsselung bereits im Setter für die Passwortvariable. Auf diese Weise wird verhindert, dass irgendwo in der Anwendung ein unverschlüsseltes Passwort zur Verfügung steht. Um nun festzustellen ob das vom Benutzer eingegebene Passwort das Richtige ist, wird das bei der Eingabe verschlüsselte Passwort mit dem Passwort aus der Datenbank verglichen. Sobald diese beiden Passwörter übereinstimmen erfolgt die Anmeldung. Die Methode, die das Verschlüsseln bewerkstelligt findet man wieder im Anhang im Listing \autoref{lstEncryptPasswort} auf Seite \pageref{lstEncryptPasswort}.\\
\\
Wie bereits weiter oben erwähnt, werden EMails zur Verifizierung bzw. Zum Zurücksetzen des Passworts verschickt. Dafür wird die JavaMailAPI von Oracle verwendet. Aus dieser API werden allerdings nur die "`mailapi.jar"' und die "`smtp.jar"' verwendet, da die anderen jar-Dateien wie z.B "`imap.jar"' nicht benötigt werden. Die JavaMailAPI bietet Methoden an, damit der Inhalt der EMail und Verbindungseigenschaften zum Server gesetzt werden können. So kann z.B. eingestellt werden, dass die Verbindung zum Server über SSL hergestellt werden soll. Im Listing \autoref{lstMailversand} auf Seite \pageref{lstMailversand} im Anhang findet man die Methode, mit der die EMails versendet werden.

\subsubsection{CreateEditAlbumController}
\label{subsubsec:CreateEditAlbumController}
Hinter diesem eigentümlichen Namen befindet sich der Controller zum Erstellen und Bearbeiten von Alben. Es liegt auf der Hand, dass sich eine Webseite zum Erstellen und zum Bearbeiten eines Albums nicht sehr unterscheiden. Daher bietet es sich an für beide Aufgaben eine Webseite mit einem Controller zu erstellen. Die wenigen Dinge die sich auf der Webseite unterscheiden werden wieder mit einem "`rendered"'-Attribut versehen. Im Controller gibt es eine Boolean-Variable "`isNewAlbum"' mit der festgestellt werden kann ob ein neues Album erstellt oder bearbeitet wird.\\
\\
Bei der Erstellung eines neuen Albums werden natürlich auch Bilder hinzugefügt. Das Hochladen der Bilder erfolgt über eine Primafaces-Komponente die auf Seite \pageref{subsec:FileUpload} im Abschnitt \autoref{subsec:FileUpload} beschrieben wird. Diese Komponente braucht eine Methode, die das von der Komponente ausgelöste FileUploadEvent entgegen nimmt und verarbeitet. Den Code der Methode findet man im Anhang auf Seite \pageref{lstHandleFileUpload} im Listing \autoref{lstHandleFileUpload}.\\
\\
Wir haben uns dazu entschieden das Bild im Dateisystem abzuspeichern und in der Datenbank lediglich den Pfad abzuspeichern. Der Grund dafür ist, dass sonst bei der Speicherung in der Datenbank die Bilder erst aufwendig encodiert werden müssten. Sobald dann später die Bilder aus der Datenbank geholt werden, müsste man außerdem wieder die Daten zu einem JPEG-Bild konvertieren. Diesen Mehraufwand konnten wir durch die Speicherung im Dateisystem umgehen. Außerdem gibt es mit unserem Verfahren weniger Probleme wenn mehrere Bilder auf einmal hochgeladen werden. Das Upload-Verzeichnis an sich liegt irgendwo im Dateisystem. Die einfachste Möglichkeit wäre zwar der web-Ordner der Applikation gewesen, aber dort wäre die Bilder bei jedem Neudeploy gelöscht worden. Aus diesem Grund gibt es ein extra Verzeichnis wo alle Bilder abgespeichert werden.\\
\\
%TODO getImage beschreiben.
\subsection{Scopes}
\subsection{Beanzugriff}
\subsection{MessageProperties}
Bei der Entwicklung einer Webapplikation ist ein wichtiges Thema was man vorher planen sollte die Internationalisierung. Weiß man von Anfang an, dass es die Applikation nur in einer Sprache geben soll, kann man die Nachrichten bzw. Texte fest hinein schreiben. Weiß man das aber zu Beginn noch nicht genau, oder möchte die Applikation in mehreren Sprachen veröffentlichen, so sollte man die JSF-Komponente message bundle verwenden. Das sorgt dafür, dass die Zeichenketten der Nachrichten unabhängig von der Applikation gespeichert werden und schnell einfacher ausgetauscht werden können, oder schon in mehreren Sprachen dort vorliegen. Um zu entscheiden welche der Sprachversionen genutzt werden soll kann man sich des Lokalisierungscodes eine JSF-Anwendung bei der Ausführung bedienen. Dieser Lokalisierungscode besteht aus zwei Teilen, dem Code der Sprache und die Festlegung eines Stattes in der die Applikation laufen soll. Welche Codes die Applikation unterstützt kann in der faces-config.xml festgelegt werden.
\begin{lstlisting}[caption=faces-config.xml Lokalisierungscode]{Name}
<locale-config>
            <default-locale>de</default-locale>
            <!--<supported-locale>de</supported-locale>-->
</locale-config>
\end{lstlisting}
Dort kann ein Standardwert festgelegt werden mit dem Tag "'<default-locale>"' und die weiteren Lokalisierungen, die unterstützt werden. In dieser Applikation wird lediglich die Lokalisierung für Deutschland unterstützt.
Des weiteren muss man festlegen, wo die Applikation die Nachrichten bzw. Texte finden kann. Das passiert ebenfalls in der faces-config.xml durch das "'<message-bundle>"' Tag.
\begin{lstlisting}[caption=faces-config.xml message bundle]
<message-bundle>bundle.message</message-bundle>
\end{lstlisting}
In diesem Fall das Package bundle und dort die Datei "'message.properties"'. \\
\\
Die Texte der Applikation werden dann wie folgt in die "'message.properties"' eingetragen:
\begin{lstlisting}[caption=message.properties]
home = Startseite
ungueltigerBenutzerName = Der Benutzername ist ungültig!
welcometext = Herzlich Willkommen auf GPicS!
\end{lstlisting}
Das sind natürlich nicht alle Nachrichten, sondern nur eine sehr kleine Auswahl um das Prinzip zu verdeutlichen.\\
\\
Um nun in einem XHTML-File auf die Nachrichten zuzugreifen, wurde in der faces-config.xml der Pfad sowie eine Variable festgelegt:
\begin{lstlisting}[caption=message.properties XHMTL-Variable]
<resource-bundle>
    <base-name>/bundle/message</base-name>
    <var>msg</var>
</resource-bundle>
\end{lstlisting}
Der Text wird dann wie folge aufgerufen:
\begin{lstlisting}[caption=message.properties Aufruf mit XHMTL-Variable]
<h:outputLabel value="#{msg.bildname} "/>
\end{lstlisting}
Mit diesem Aufruf wird folgende Zeile der "'message.properties"' aufgerufen:
\begin{lstlisting}[caption=message.properties XHMTL-Variable Teil 2]
bildname = Name
\end{lstlisting}
Somit wird das Label den Namen "'Name"' bekommen.\\
\\
Will man in einem Controller auf die "'message-properties"' zugreifen, geht das wie folgt.
Die jeweiligen Nachrichten werden dann durch folgende Methode an der jeweiligen Stelle der Applikation aus der "'message.properties"' geladen:
\begin{lstlisting}[caption=message.properties Aufruf aus Controller]
MessagePropertiesBean msgPB = new MessagePropertiesBean();
String pfad = msgPB.getPropertiesMessage("defaultPicturePath");
\end{lstlisting}

Dafür wird die die Methode "'getPropertiesMessage()"'  der Klasse MessagesPropertiesBean aus dem Package util genutzt.

\begin{lstlisting}[caption=message.properties Aufruf aus Controller Teil 2]
public String getPropertiesMessage(String key) {

		FacesContext context = FacesContext.getCurrentInstance();

		String text = GPicSUtil.getMessageResourceString(context.getApplication()
                .getMessageBundle(), key, null, context.getViewRoot()
                .getLocale());

return text;
	}
\end{lstlisting}

Der Methode wird ein String übergeben, der wiederum einer weiteren Methode der Klasse GPicSUtil übergeben wird.

\begin{lstlisting}[caption=message.properties Aufruf aus Controller Teil 3]
public static String getMessageResourceString(
    String bundleName,
    String key,
    Object params[],
    Locale locale){

        String text = null;

        ResourceBundle bundle =
                ResourceBundle.getBundle(bundleName, locale,
                                        getCurrentClassLoader(params));

        try{
            text = bundle.getString(key);
        } catch(MissingResourceException e){
            text = "?? key " + key + " not found ??";
        }

        if(params != null){
            MessageFormat mf = new MessageFormat(text, locale);
            text = mf.format(params, new StringBuffer(), null).toString();
        }

    return text;
}
\end{lstlisting}
Diese Methode durchsucht dann das "'message-properties"'-File und gibt den Text zurück, soweit er gefunden wird.
\subsection{EMail}
Für die Benutzerkontoerstellung und das Zusenden eines neuen Passworts haben wir in unserem Projekt die Möglichkeit vorgesehen EMails zu versenden. Da der EMail-Versand zwingend ein EMail-Account erfordert, haben wir einen Mailserver eingerichtet, womit diese EMails verschickt werden konnten. Allerdings haben wir relative schnell Probleme festgestellt. So funktionierte das Schicken der Mails nur an die Hochschul-EMail-Adresse. Bei anderen Mail-Anbietern kamen keine EMails an. Sie wurden noch nicht einmal im Spam Ordner angezeigt. Der Grund hierfür liegt wahrscheinlich darin, dass die anderen Mail-Anbieter unsere Adresse nicht als vertrauenswürdig einstuften.\\
\\
Dies war aber nicht das einzigste Problem. Probleme mit unserem VServer erzwangen ein Neustart des Mail-Servers. Danach hat das Senden von Mails nicht mehr funktioniert. Wo die Gründe liegen ist leider nicht ohne eine aufwendige Problemanalyse raus zu bekommen. In Anbetracht der knappen Zeit haben wir uns dafür entschieden, bei GMX ein Mailkonto einzurichten und über diese Adresse die Mails zu schicken.\\
\\
Nun steht natürlich die Frage im Raum warum wir das nicht von Anfang an gemacht haben und uns mit dem Aufwand, dem Einrichten eines Mailservers, viel Arbeit aufgeladen haben. Der Grund dafür waren bedenken, einen "`Sinnlos-Account"' einzurichten. Es werden ja nur einige wenige EMails versendet. Außerdem macht eine eigene EMail-Adresse immer einen besseren Eindruck. Wäre mehr Zeit gewesen hätten wir sicher das Problem mit unserem Mailserver lösen können, aber so mussten wir eben diese Alternative verwenden.