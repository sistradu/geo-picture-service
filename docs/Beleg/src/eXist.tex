\section{eXist}
\label{JumpeXist}
Ein zentraler Bestandteil des Fotoarchivs ist die Datenbank. Hier werden alle wichtigen Informationen zu Nutzern, Bildern und Alben gespeichert.
Da XML-Dokumente verarbeitet werden, liegt es nahe, eine native XML-Datenbank zum Speichern der Daten zu verwenden. In diesem Projekt wird eXist verwendet, was im Folgenden begründet werden soll.
\subsection{Warum kein relationales Datenbankmanagementsystem?}
Relationale Datenbanken basieren auf einem gut durchdachten Konzept, das sich jahrelang bewährt hat und bieten wichtige Vorzüge, die man bei einer nativen XML-Datenbank wie eXist nicht vorfindet:
\begin{enumerate}
	\item Referentielle Integrität:
	\item[] In nativen XML-Datenbanken kann dieser Punkt leider nicht garantiert werden. Hier muss von Hand sichergestellt werden, dass alle Referenzen auf ein gelöschtes Objekt ebenfalls gelöscht werden. Da das Datenmodell aber überschaubar ist, stellt dieser Punkt kein großes Problem dar.
	\item Sequenzen zur Vergabe eindeutiger Primary Keys:
	\item[] Gerade bei einem Multinutzersystem ist dieser Punkt klar von Vorteil. Bei der Verwendung nativer XML-Datenbanken, muss dieses Problem in der Regel auf eine andere Art und Weise gelöst werden. Näheres dazu unter \autoref{JumpDBZugriffe}.
\end{enumerate}
Da relationale Datenbanken aber nicht primär für die Speicherung von XML-Dateien geeignet sind, müssen die, von einem XML-basierten Fotoarchiv verwendeten Dokumente, zunächst transformiert werden, um diese in der Datenbank zu speichern. Möglichkeiten dazu sind beschrieben unter \cite{Kle01}. Das kann aber schnell sehr ineffizient werden, wenn die Dateien immer größer werden oder es können nur Dateien mit einem bestimmten Aufbau verwendet werden.\\
Eine Möglichkeit wäre noch, die Dateien einfach als reine Zeichenketten in der Datenbank zu hinterlegen. Doch auch dieser Ansatz ist sehr ineffizient, da das Durchsuchen der Dateien nach bestimmten Informationen so viel zu lange dauert. Zwar gibt es auch relationale Datenbanken mit einer speziellen Erweiterung für XML-Dateien wie Oracle oder MS-SQL, doch sind diese in der Regel schlicht und einfach zu mächtig, also sehr groß und dadurch in der Anwendung vergleichsweise kompliziert.
\subsection{Native XML-Datenbanken}
Aus den oben genannten Fakten begründet sich die Entscheidung, eine native XML-Datenbank zu verwenden. Diese sollte folgende Eigenschaften besitzen:
\begin{enumerate}
	\item Geringe Größe:
	\item[] Auf dem verwendeten Testserver steht nur begrenzt Speicherplatz zur Verfügung wobei dieser auch größtenteils für die Bilder genutzt werden soll. Somit darf die Datenbank nicht zu viel Platz belegen.
	\item Schnelle Installation und Einrichtung:
	\item[] Die Datenbank stellt ein wichtiges Kernelement des Systems dar und sollte demnach so früh wie möglich einsatzfähig sein, um erste lauffähige Versionen des Fotoarchivs ausgiebig testen zu können.
	\item Möglichst einfaches Auslesen und Verwalten der Daten:
	\item[] Auch dieser Punkt ist wichtig, damit die Datenbank so früh wie möglich einsatzfähig ist. Zudem muss es möglich sein, eventuelle Fehler schnell beheben zu können, z.B. durch das manuelle Löschen eines fehlerhaften Eintrags aus einer Datei.
	\item Kostenfrei
\end{enumerate}
Zudem sollte die Datenbank einige wichtige Eigenschaften relationaler Datenbanksysteme beherrschen, unter anderem:
\begin{enumerate}
	\item Effiziente und strukturierte Speicherung:
	\item[] Viele native XML-Datenbanken, verwenden einen modellbasierten Ansatz zur Speicherung der Daten, was eine schnellere und effizientere Suche, als bei XML fähigen Datenbanken, die eine rein zeichenkettenbasierte Speicherung der Daten vornehmen, ermöglicht. 
	\item Indizes:
	\item[] Deren Verwendung bewirkt ebenfalls schnellere Suchvorgänge. eXist zum Beispiel, erzeugt bereits einige wichtige Indizes, welche in der Regel auch ausreichen um vor allem XPath und XQuery zu beschleunigen. Es können aber noch weitere Indizes in den Konfigurationsdateien zu jeder Collection vom Nutzer definiert werden.
	\item Transaktionssicherheit:
	\item[] Die Datenbank sollte in der Lage sein nach einem Absturz, alle vollständig beendeten Transaktionen wiederherzustellen und alle nicht abgeschlossenen Transaktionen zurückzusetzen.
\end{enumerate}
eXist erfüllt alle diese Vorraussetzungen und tatsächlich gibt es kaum weitere native XML-Datenbanksysteme, die als Alternative in Frage kämen (vgl. \cite{BR02}). Im \autoref{JumpXMLDBCompare} werden kurz 3 weitere Systeme, die noch näher betrachtet wurden, mit eXist verglichen.\\
%Footnotes müssen manuell gesetzt werden, da diese in einer Gleitumgebung wie Tabellen nicht funktionieren
\begin{table}
\begin{center}
	\begin{tabular}{|c|c|p{4cm}|c|}
		\hline
		\textbf{Entwickler} & \textbf{Datenbank} & \textbf{Besonderheiten} & \textbf{Aktuelle Version} \\
		\hline
		\hline
		Wolfgang Meier & eXist\footnote{} & Open Source, ständige Updates, große Community, beherrscht XQuery, gut dokumentiert & 1.4 (23.12.2010) \\
		\hline
		Apache & Xindice\footnote{} & kostenlos verfügbar unter der Apache License & 1.2m1 (01.12.2007) \\
		\hline
		EMC & xDB\footnote{} & beherrscht XQuery, gut dokumentiert, wird immer noch weiterentwickelt, benötigt Registrierung  & 10.1.0 (21.07.2010) \\
		\hline
		Software AG & Tamino\footnote{} & beherrscht XQuery, gut dokumentiert, benötigt Registrierung, 3 Versionen (eine kostenfreie) & 4.4.1 (unbekannt) \\
		\hline
	\end{tabular}\\
	\caption{Vergleich nativer XML-DB Systeme}
	\label{JumpXMLDBCompare}
\end{center}
\end{table}
\footnotetext[1]{\url{http://www.exist-db.org/documentation.html}}    
\footnotetext[2]{\url{http://xml.apache.org/xindice/index.html}}   
\footnotetext[3]{\url{https://community.emc.com/docs/DOC-3155}}   
\footnotetext[4]{\url{http://www.softwareag.com/de/products/wm/tamino/}}
Dabei ist eXist das einzige System, das komplett kostenlos zur Verfügung steht und ständig weiterentwickelt wird.  Zudem ist es durch die inzwischen sehr große Community sehr einfach, auftretende Probleme schnell zu klären ohne sich durch lange Dokumentationen kämpfen zu müssen. Insgesamt erscheint eXist von allen auch am übersichtlichsten. Somit ist es das System, welches am besten für diese Anwendung geeignet ist.
\subsection{Installation}
Um eXist nun zu installieren werden mehrere Möglichkeiten angeboten (vgl. \cite{MO10}):
\begin{itemize}
	\item Embedded:
	\item[] Hierbei wird die Datenbank im Grunde als Java-Bibliothek behandelt und läuft damit in der selben JVM wie die Applikation. Vorteil ist, dass keine Netzwerkverbindung zur Datenbank aufgebaut werden muss. Ein großer Nachteil dabei ist aber, dass Applikation und Datenbank nicht getrennt lauffähig sind.
	\item Standalone:
	\item[] Hier läuft die Datenbank in einer eigenen JVM ohne in einen Webserver eingebunden zu sein. Die Datenbank läuft dadurch zwar getrennt von der Applikation, aber es stehen nicht alle Funktionalitäten zur Verfügung.
	\item Als Servlet-Context:
	\item[] Hier läuft die Datenbank als Teil einer Webapplikation und wird mit dieser deployed. Standartmäßig wird dazu ein Jetty als Servlet-Engine mitgeliefert. Es ist zwar laut Entwickler nicht schwierig, eXist auch auf einem anderen Server zu deployen, aber es wird empfohlen keine andere Servlet-Engine zu nutzen, falls es nicht zwingend erforderlich ist. Begründet wird das dadurch, dass Jetty klein, effizient und stabil ist und eXist vorwiegend darauf getestet wurde. Diese Lösung ist zwar, durch andere auf dem Server laufenden Prozesse, ein wenig ineffizienter, als die Standalone-Variante, dennoch wird diese verwendet, da hier sämtliche Zugriffs- und Administrationsmöglichkeiten zur Verfügung stehen.
\end{itemize}
\subsection{Abfrage der Daten}
Nach der Installation ging es darum sich zu entscheiden, welche Art der Zugriffsmethode verwendet werden soll, um die Daten in der Datenbank auszulesen und diese zu modifizeren. Auch hier bietet eXist mehrere Möglichkeiten an (vgl. \cite{Mei09Dev}):
\begin{itemize}
	\item Java-Admin Client:
	\item[] Dieser Client kann verwendet werden um schnell und effektiv aufgetretene Fehler in der Datenbank zu beheben. So können bequem Collections angelegt werden, die ungefähr wie Tabellen in einer relationalen Datenbank fungieren. Innerhalb dieser Collections können dann ein oder mehrere XML-Dateien gespeichert werden. Auch das Hochladen von Dateien ist sehr einfach und unkompliziert. Auch können mit dem Admin-Client sehr einfach die Zugriffsrechte auf Collections oder einzelne Dateien geändert werden. Das ist wichtig, damit die gespeicherten Informationen, später nicht von dritten ausgelesen werden können. Für den Zugriff aus der Applikation heraus, benötigen wir aber eine andere Lösung.
	\item XML:DB API:
	\item[] Eine Möglichkeit ist es, die XML:DB API zu verwenden. Diese API stellt ein Interface für XML-Datenbanken zur Verfügung. Die eXist Implementierung von XML:DB orientiert sich dabei an Xindice von Apache. Ein Vorteil dieser Methode ist die gute Dokumentation, womit anhand von Beispielen auch schnell erste Erfolge erzielt werden können. Nachteilig ist, dass zur Verwendung zunächst das dazugehörige Framework eingebunden werden muss.
	\item XML-RCP API:
	\item[] eXist stellt ebenfalls eine XML-RPC API bereit, damit der Zugriff auf die Datenbank möglichst Programmiersprachenunabhängig ist. Auch hier wird eine sehr gute Dokumentation mit gut erklärten Beispielen bereitgestellt. Allerdings ist auch hier die Einbindung weiterer Bibliotheken in unser Projekt nötig.
	\item REST-style API:
	\item[] Die mit Abstand beste Möglichkeit um auf die Datenbank zuzugreifen, bietet sich über simple HTTP-Requests. Dafür ist nicht viel Quellcode erforderlich, es müssen keine großen Bibliotheken eingebunden werden und mit der Möglichkeit Stored XQuerys aufzurufen, können alle benötigten Abfragen direkt in der Datenbank hinterlegt werden, was nochmals den Implementationsaufwand auf Clientseite reduziert. Darum wird in diesem Projekt auch diese Variante verwendet.
\end{itemize}
\subsection{One BIG vs. Many small}
\label{JumpDBOneBIGManysmall}
Eine interessante Fragestellung die sich für den Aufbau der Datenbank ergab war, ob Operationen auf einer großen Datei mit vielen Einträgen oder auf vielen kleinen Dateien mit jeweils wenig Einträgen schneller sind.\\
Da das System für mehrere Nutzer geeignet sein sollte, war es besonders wichtig zu testen, ob die Datenbank mit sehr vielen Einträgen überhaupt umgehen kann und welche Art der Speicherung der Daten vorteilhafter ist. Dazu wurden zunächst die möglichen Ausmaße der Daten ermittelt, wobei von etwa 10 Benutzern mit durchschnittlich 20 Alben mit jeweils 50 Bildern ausgegangen wurde. Klar wird, dass der Schwachpunkt hier bei den insgesamt $10 * 20 * 50 = 10000$ Bildern liegt. Bei diesen Ausmaßen ist es auch nicht mehr vorteilhaft, die Fotos ebenfalls in der Datenbank zu speichern. Da die Datenbank versucht, Daten und vor allem Indizes im Arbeitsspeicher zu Cachen, würde dieser so bei sehr großen Fotos schnell voll werden. Würde die JVM damit mehr Speicher benötigen, als ihr zugewiesen wurde (Der Standartwert liegt bei 512 MB), dann würde die komplette Datenbank abstürzen. Es gibt zwar Mechanismen, die das verhindern sollen, dennoch wird auf der offiziellen Webseite darauf hingewiesen, dass es zu drastischen Performance-Einbrüchen kommen kann, wenn mehrere 100 MB an XML-Dateien verwaltet werden sollen (siehe: \cite{Mei09}). Da die Bilder der verwendeten Kamera jeweils etwa 4MB groß sind, ist dieser Punkt schnell erreicht. Bei 10000 Bildern entspräche das etwa 39GB.\\
Nun blieb noch zu ermitteln, ob jetzt eine große oder mehrere kleine Dateien sinnvoller sind. Dazu wurden Dateien mit einigen Testdaten generiert. Darunter eine große Datei mit insgesamt 10000 Einträgen (One BIG) und 500 kleine Dateien mit jeweils 20 Einträgen (Many small). Auf diesen Dateien wurden mehrere Abfragen ausgeführt und die ermittelten Resultate in der folgenden Tabelle zusammengefasst.

\begin{table}
	\begin{center}
		\begin{tabular}{|l|c|c|}
			\hline
			& \textbf{One BIG} & \textbf{Many small} \\
			\hline
			\textbf{Einträge pro Datei} & 10000 & 20 \\
			\hline
			\textbf{Anzahl Dateien} & 1 & 500 \\
			\hline
			\textbf{Dateigröße} & 1,5 MB & 3 KB \\
			\hline
			\textbf{Auslesen aller Einträge} & 7 sec & 6 sec \\
			\hline
			\textbf{Aulesen aller mit Cache} & 3 sec & 3 sec \\
			\hline
			\textbf{Suchen eines bestimmten Eintrages} & < 1 sec & < 1 sec \\
			\hline
			\textbf{Suchen mehrerer Einträge} & 3 sec & 2 sec\\
			\hline
		\end{tabular}
		\caption{One BIG vs. Many small}
		\label{JumpTableOneBIGManysmall}
	\end{center}
\end{table}
Dabei ist erkennbar, dass die Menge der Dateien und deren Größe kaum Einfluss auf die Geschwindigkeit der Abfragen hat. Der Grund dafür sind die Indizes, die eXist automatisch erzeugt. Dadurch können unabhängig von der Dateigröße, schnell bestimmte Einträge gefunden werden, ohne immer wieder einen kompletten Scan durchzuführen. Nach der ersten Abfrage aller Daten, werden zudem die Dateien im Cache der Datenbank gehalten, womit künftige Suchanfragen nochmals beschleunigt werden. Das funktioniert bei diesem System auch bei 10000 Einträgen problemlos, da wir ja die Fotos nicht in der Datenbank speichern. Trotzdem müssen die Dateien noch irgendwo im Dateisystem gespeichert werden. Darum wurde die Variante mit jeweils einer großen Datei gewählt, da dies weniger Verwaltungsaufwand bedeutet, vor allem da die kleinen Dateien mit 3KB sogar noch unter der Blockgröße aktueller Dateisysteme liegen und somit insgesamt mehr Speicher belegen als notwendig.