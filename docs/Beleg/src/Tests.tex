\chapter{Tests}
\label{JumpTests}
%TODO Aufteilen in Unterabschnitte
\section{UserControllerTest}
Um nach Änderungen sicher zu sein das die Klasse noch richtig funktioniert müssen Tests durchgeführt werden. Aus diesem Grund wurden beim UserController die Methoden sendPasswortEmail, Login, Logout, erzeugeBenutzer, setPasswort und updateBenutzer getestet. Dabei soll vor allem überprüft werden, ob auch wirklich im Controller die Attribute richtig gesetzt werden. So wird zum Beispiel in der Methode testSendPasswortEmail nicht überprüft, ob eine EMail versendet wird, sondern ob ein neues zufälliges Passwort generiert wurde.\\
\\
Leider treten bei den meisten Tests Fehler auf. Das liegt hauptsächlich daran, dass aus einem Controller heraus Nachrichten auf der Webseite gesetzt werden sollen. Dazu wird der FacesContext verwendet. Dieser ist allerdings bei einem Test stets null. Daher sind wirklich sinnvolle Tests nicht mehr möglich. Ein Framework was bei diesem Punkt Abhilfe schaffen könnte wäre JSFUnit. Für eine Evaluierung dieses Frameworks war aber keine Zeit mehr sodass es in diesem Projekt nicht eingesetzt wird.

\section{ImageDataExtractorTest und CoordinateCalculatorTest}
Für die Extrahierung der Geo-Daten aus den Bildern ist auch ein Test erstellt worden. Damit sollte sichergestellt werden, dass die GPS-Koordinaten richtig aus einem Bild geholt werden. Die Erzeugung eines Thumbnails aus dem Bild mit dem Framework "`Metadata Extractor"' wurde ebenfalls überprüft. Dazu ist auf dem Server auch ein Testbild mit Geoinformationen bereitgestellt worden, so dass der Build-Server die Test ordentlich durchführen kann.\\
\\
Der CoordinateCalculatorTest überprüft ob die Umrechnung der Koordinaten von z.B. N 51''8'55.8, E 14''59'55.985 in das von Google gewünschte Dezimalformat\\ (z.B.: 51.148833333333336, 14.998884722222222) richtig arbeitet.\\
\\
\section{GPicSUtilTest und PasswortUtilTest}
In der Klasse GPicSUtil werden einige Hilfsmethoden bereitgestellt, die an mehreren Stellen bei den Controllern benötigt werden. Es wurde hier besonders die Methode getStreamedContent überprüft. Diese soll von ein Bild von der Festplatte holen und es als StreamedContent zurückgeben. Nach einem Aufruf der Methode darf also das zurückgegebene StreamedContent-Objekt nicht null sein. Sollte dies nicht der Fall sein, ist der Test erfolgreich durchgelaufen.\\
\\
Die Klasse PasswortUtil stellt zwei Methoden zur Verfügung. Eine soll ein Passwort mit MD5 verschlüsseln und die zweite ein zufälliges Passwort erzeugen. Für den Verschlüsselungstest wurde ein Wort ausgewählt, wo der MD5-Hash schon bekannt ist. Dann wurde dieses Wort an die Methode übergeben und der Rückgabewert mit dem bekannten MD5-Hash verglichen. Der Test ist erfolgreich, wenn die beiden Werte gleich sind. Für den zweiten Test wird die Methode zum Erzeugen von Zufallspasswörtern zweimal aufgerufen und anschließend die beiden Rückgabewerte miteinander verglichen. Diese beiden Werte dürfen nicht gleich sein. Sollte dies dennoch der Fall sein schlägt der Test fehl.

\section{Datenbank-Tests}
\subsection{Mockklassen}
Natürlich muss auch die Datenbank entsprechend getestet werden, damit sichergestellt werden kann, dass die verwendeten Daten in den Controllern korrekt ausgelesen wurden und auch wieder korrekt geschrieben werden. Da zunächst nur Mockklassen implementiert wurden, waren auch Tests für diese nötig. Denn auch wenn es sich nur um Testdaten handelt, ist eine korrekte Funktionsweise von größter Wichtigkeit. Die Tests dafür wurden entsprechend umfangreich aufgebaut. Da die Mockklassen nur Daten liefern, aber noch keine Daten speichern, ändern oder löschen können, mussten immerhin nicht alle Methoden getestet werden.\\
Der Ablauf der Tests unterscheidet sich dabei kaum untereinander und läuft immer nach folgendem Schema:
\begin{enumerate}
	\item Initialisieren des MockConnectors
	\item Aufruf der zu testenden Methode
	\item Auslesen alle erwarteten Nodes aus dem erhaltenen Dokument
	\item Prüfen der Anzahl der Nodes
	\item Prüfen der einzelnen Inhalte der Nodes
\end{enumerate}
Dieser strukturierte Ablauf wurde gewählt, damit genau nachvollzogen werden kann, an welcher Stelle ein falsches Resultat geliefert wurde. Auf Grund der Menge an zu prüfenden Elementen werden diese Tests natürlich auch sehr schnell sehr groß, weshalb ein strukturierter Aufbau umso wichtiger ist. Die einzigen Ausnahmen sind Tests mit falschen Eingaben, wie einer nicht existierenden ID, bei denen eine Exception erwartet wird. Wird diese nicht geworfen, schlägt der Test fehl, ansonsten ist alles in Ordnung.
\subsection{XQueries}
Um die korrekte Funktion der XQueries testen zu können und auch den korrekten Aufruf dieser über den DBConnector, muss auch mit einer echten Datenbank-Instanz gearbeitet werden. Dazu sollte aber nicht die Datenbank für unser Projekt verwendet werden. Also wurde eine lokale Datenbank eingerichtet und die Möglichkeit, die Adresse der Datenbank im DBConnector zu ändern eingerichtet. Die lokale Datenbank wurde im Anschluss mit den selben Testdaten, die auch schon die Mockklassen verwenden bestückt. Dazu mussten nur die Dokumente, die die Mockklassen erzeugen in eine Datei geschrieben wurden und über den Admin-Client von eXist hochgeladen werden. Durch die vorangegangenen Tests für die Mockklassen, konnte davon ausgegangen werden, dass die in den Dokumenten enthaltenen Daten korrekt sind.\\
Bei den Tests der Funktionen, die auch die Mockklassen implementiern, gibt es dabei auch kaum Unterschiede zu den Tests der Mockklassen, da die selben Daten verwendet werden. Zusätzlich mussten aber noch Funktionen wie das Ändern, Hinzufügen oder Löschen von Daten getestet werden. Das war aber auch kein großes Problem da hier die Methoden zum Laden der Daten verwendet werden konnten Diese wurden ja durch die anderen Tests bereits abgedeckt. Es musste also nur noch geprüft werden ob die Daten sich korrekt von den ursprünglichen Daten unterscheiden.