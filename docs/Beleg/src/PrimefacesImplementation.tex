\section{Primefaces}
\label{JumpPrimefacesImplementation}
\subsection{FileUpload}
Für das Hochladen der Bilder wird im Projekt die File-Upload Komponente von PrimeFaces verwendet. Dadurch konnte diese Anforderung relativ schnell umgesetzt werden. Zu Beginn traten allerdings einige Probleme auf. So benötigt diese Komponente eine Reihe von Biblotheken damit der Upload funktioniert. Dies wurde allerdings weder auf der PrimeFaces-Webseite noch in der PDF-Dokumentation erwähnt. Letztendlich musste eine Recherche im Internet gemacht werden, wo dann in einem Forum erwähnt wurde, dass die Bibliotheken "`commons-logging"', "`commons-io"' und "`commons-fileupload"' benötigt werden. Diese sind alle Projekte der Apache Foundation und somit trat bei der Verwendung auch keine lizenzrechtlichen Probleme auf.\\
\\
Grundvoraussetzung für die Verwendung der Fileupload-Komponente ist, dass einige zusätzliche Filter in die web.xml eingetragen werden. Welche Filter einzubinden sind, findet man in der PDF-Dokumentation von Primefaces.
\begin{lstlisting}[caption=Fileupload-Filter]
<filter>
        <filter-name>PrimeFaces FileUpload Filter</filter-name>
        <filter-class>
            org.primefaces.webapp.filter.FileUploadFilter
        </filter-class>
    </filter>
    <filter-mapping>
        <filter-name>PrimeFaces FileUpload Filter</filter-name>
        <servlet-name>Faces Servlet</servlet-name>
    </filter-mapping>
\end{lstlisting}
Ansonsten ist die Verwendung der Komponente ziemlich einfach. Als erstes muss die Komponente in eine HTML-Seite eingebunden werden.
\begin{lstlisting}[caption=Fileupload-Komponente einbinden, label=lstFileupload]
<p:fileUpload widgetVar="uploader" customUI="true" label="#{msg.uploadImage}" description="*.jpg;*.JPG" allowTypes="*.jpg;*.JPG" fileUploadListener="#{createEditAlbumController.handleFileUpload}" multiple="true" id="fileUploader" update="messages, cgrid"/>
\end{lstlisting}
Es ist sogar möglich die Schaltflächen umzubenennen. Diese Möglichkeit wurde natürlich genutzt. Wie in dem Listing \autoref{lstFileupload} zu sehen ist, wurden die Beschriftungen allerdings nicht fest reingeschrieben sondern mit einem Eintrag in der Message.properties verknüpft. Außerdem wurden nur Dateien für den Upload zugelassen, die die Endung "`.jpg"' bzw. "`.JPG"' haben. Sobald man ein Bild hochlädt, wird ein FileUploadEvent ausgelöst. Mit dem entsprechenden Event-Objekt kann man auf die Daten zugreifen. 
%\begin{lstlisting}[caption=FileUploadEvent]
%public void handleFileUpload(FileUploadEvent event) {
        %UploadedFile file = event.getFile();
        %try {
            %...
            %out = new FileOutputStream(uploadDir + username + "_" + file.getFileName());
            %out.write(file.getContents());
            %out.flush();
            %out.close();
            %....
    %}
%\end{lstlisting}
%TODO Referenz einfügen
Die genaue Implementation des FileUploadEvents wird noch im Abschitt beschrieben.
%Wir haben uns dazu entschieden das Bild im Dateisystem abzuspeichern und in der Datenbank lediglich den Pfad abzuspeichern. Der Grund dafür ist, dass sonst bei der Speicherung in der Datenbank die Bilder erst aufwendig encodiert werden müssten. Sobald dann später die Bilder aus der Datenbank geholt werden, müsste man außerdem wieder die Daten zu einem JPEG-Bild konvertieren. Diesen Mehraufwand konnten wir durch die Speicherung im Dateisystem umgehen. Außerdem gibt es mit unserem Verfahren weniger Probleme wenn mehrere Bilder hochgeladen werden.\\
%\\
%Das Upload-Verzeichnis an sich liegt irgendwo im Dateisystem. Die einfachste Möglichkeit wäre zwar der web-Ordner der Applikation gewesen, aber dort wäre die Bilder bei jedem Neudeploy gelöscht worden. Aus diesem Grund gibt es ein extra Verzeichnis wo alle Bilder abgespeichert werden.

\subsection{GMap}
Primefaces bietet noch weitere nützliche Komponenten. So wird bereits eine Komponente zum Anzeigen einer GMap-Karte bereitgestellt. Um diese einzubinden muss nur der in Listing \autoref{lstGMap} zu sehende Code in die Webseite eingebunden werden.
\begin{lstlisting}[caption=GMap-Tag, label=lstGMap]
<p:gmap center="#{albumController.bilder[0].latitude}, #{albumController.bilder[0].longitude}" zoom="13" type="HYBRID" style="width:600px;height:400px"
                    model="#{mapBean.simpleModel}" overlaySelectListener="#{mapBean.onMarkerSelect}">
</p:gmap>
\end{lstlisting}
Voraussetzung für die Verwendung des GMap-Tags ist allerdings der folgende JavaScript-Code, mit dem die GoogleMaps-API eingebunden wird.
\begin{lstlisting}[caption=Einbinden der GoogleMaps-API]
<script src="http://maps.google.com/maps/api/js?sensor=true" type="text/javascript"></script>
\end{lstlisting}
Für das Anzeigen der Bilder in der GMap-Karte gibt es verschiedene Möglichkeiten. So wird bereits in dem Showcase auf der Primefaces-Webseite vorgeschlagen für jedes Bild ein Marker zu verwenden und bei einem Klick auf den Marker eine Sprechblase mit dem Bild anzuzeigen. Dafür muss zwischen den öffnenden und den schließenden GMap-Tag der Inhalt des Listings \autoref{lstInfoWindow} eingetragen werden.
\begin{lstlisting}[caption=GMap-InfoWindow, label=lstInfoWindow]
<p:gmapInfoWindow>
                        <p:graphicImage value="#{mapBean.image}" width="200" height="150"/>
                        <br/>
                        <h:outputText value="#{mapBean.beschreibung}"/>
                    </p:gmapInfoWindow>
\end{lstlisting}
Das Hinzufügen der Marker und was bei einem Klcik auf einem Marker passiert, muss in der dazu gehörigen ManagedBean erfolgen. Die wird in Abschnitt ???????????? noch erläutert.\\
\\
Eine andere Möglichkeit wäre, die Bilder direkt in der GMap anzuzeigen. In einem Wegwerfprojekt, das durchgeführt wurde um Primefaces genauer kennen zu lernen, wurde festgestellt, dass die möglich ist. Dazu müssten die Marker nicht mehr das Bild des Markers anzeigen sondern das gewünschte Bild. Es wurde allerdings festgestellt, dass dies nur mit Bildern gehen würde, die im Web-Ordner des Tomcats zur Verfügung stehen. Dazu müsste der Pfad bekannt sein. Mit dynamisch gestreamten Bildern von der Festplatte war das Ersetzen des Marker-Bildes nicht möglich. Außerdem stellte sich bei diesem Versuch heraus, dass ein Anzeigen der Bilder direkt in der Map zu viel von der eigentlichen Map verdeckt. Daher wird die erste Möglichkeit in diesem Projekt verwendet.