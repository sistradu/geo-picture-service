\section{Benutzeroberfläche}
\label{JumpBenutzeroberflaeche}
%TODO Anpassen, Facelets rein
Die Benutzeroberfläche besteht aus drei Komponenten, HTML, YAML und Facelets. Als Grundgerüst nutzen wir eine HTML-Seite die folgende Struktur besitzt. 
\begin{lstlisting}[caption=HTML-Grundgerüst]{Name}
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
	<title>GPicS</title>
	<link href="yaml/css/my_layout.css" rel="stylesheet" type="text/css"/>
</head>
<body>
</body>
</html>    
\end{lstlisting}
Dieser kurze Auszug zeigt nicht dem kompletten Quellcode aber die wichtigsten Grundelemente.
//
Grundelemente etwas erklären
//
Zudem kommt bei uns die View-Handler-Technologie Facelets zum Einsatz, welche eine Alternative zum JavaServer Faces(JSF) Framework bildet. Mit ihr ist es möglich eine Seite als Layout zu definieren und diese immer mit dem aktuell anzuzeigenden Content zu füllen. Facelets verfügt über component-aliasing, was dafür sorgt, dass normale HTML-Tags statt der Tags für UI-Komponenten genutzt werden können. Um eine Verbindung zu den jeweiligen UI-Komponenten herzustellen reicht es aus das alias-Attribut jsfc im Tag anzugeben. Hier ein kleines Beispiel:
\begin{lstlisting}[caption=Facelets HTML-Tag]{Name}
<html   xmlns:ui="http://java.sun.com/jsf/facelets" xml:lang="en" lang="en">
<body>
<ui:insert name="content"/>
</body>
</html>
\end{lstlisting}
Wie im Beispiel zu sehen ist, wird im Body ein HTML-Tag mit dem Namen "content" eingefügt. Dieses muss im weiter Verlauf nur immer mit dem jeweiligen Inhalt versorgt werden. Dies passiert wie folgt.
\begin{lstlisting}[caption=Facelets HTML-Tag]{Name}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE composition PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<ui:composition xmlns="http://www.w3.org/1999/xhtml" xmlns:jsp="http://java.sun.com/jsf/composite" xml:lang="en"
                lang="en"
                template="layout.xhtml"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                xmlns:f="http://java.sun.com/jsf/core"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:p="http://primefaces.prime.com.tr/ui">

    <ui:define name="content">
    	 Hier würde jetzt der Content der jeweiligen Seite definiert werden
    </ui:define>

</ui:composition>
\end{lstlisting}
Man erstellt eine neue XHTML-Seite und legt auf dieser Seite im UI-Tag "composition" mittels der Zuweisung "template="layout.xhtml"" das Layout was genutzt werden soll fest. In diesem Fall die "layout.xhtml". Der eigentliche Inhalt für den UI-Tag "content" legt man mit Hilfe des Tags "<ui:define name="content"" fest. \\
Das hat den Vorteil das man sich nicht auf jeder Seite damit beschäftigen muss, wo soll der Tag später angezeigt werden, sondern man definiert ihn nur und er wird immer an der Stelle, wo er im Template festgelegt ist angezeigt.\\
\\
Wie nun das HTML-Layout gestaltet ist wird mittels CSS durch das YAML-Framework festgelegt, welches wir bis auf ein paar kleine Änderungen in Sachen Hintergrundgrafik fast ungeändert nutzen. Es bietet durch mehrere CSS-Style-Sheets den Vorteil in allen gängigen Browsern gut dargestellt werden zu können. Es enthält speziel für den Internet-Explorer angepasste Sytle-Sheets, da dieser mit den üblichen CSS-Befehlen nicht zurecht kommt bzw. diese immer etwas anders umsetzt. Damit ist zum Beispiel gemeint, das ein deutlicher Unterschied zwischen Firefox und Internet-Explorer besteht wenn man einen Abstand mit 10px definiert. Das kann zu deutlichen Unterschieden führen, welche aber durch YAML bereits abgefangen werden. Zudem kümmert sich YAML auch um die weiteren browserspezifischen Bugs, was den Vorteil hat, dass sich der Programmierer nicht noch mit jeden Browser beschäftigen muss, sondern eine Lösung für alle Browser implementieren kann.




